(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{209:function(v,_,a){"use strict";a.r(_);var t=a(0),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("p",[v._v("维基百科里是这么说的：")]),v._v(" "),a("blockquote",[a("p",[v._v("散列（英语：Hashing）是电脑科学中一种对数据的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。旧译哈希（误以为是人名而采用了音译）")]),v._v(" "),a("p",[v._v("它也常用作一种信息安全的实现方法，由一串数据中经过散列算法（Hashing algorithms）计算出来的数据指纹（data fingerprint），经常用来识别文件与数据是否有被窜改，以保证文件与数据确实是由原创者所提供")]),v._v(" "),a("p",[v._v("如今，散列算法也被用来加密存在数据库中的密码（password）字符串，由于散列算法所计算出来的散列值（Hash Value）具有不可逆（无法逆向演算回原本的数值）的性质，因此可有效的保护密码。")])]),v._v(" "),a("p",[v._v("一下本文，全部以哈希称呼 "),a("code",[v._v("Hash")])]),v._v(" "),a("h2",{attrs:{id:"so-what-s-it"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#so-what-s-it"}},[v._v("#")]),v._v(" so what's it")]),v._v(" "),a("p",[v._v("到底哈希是什么呢？")]),v._v(" "),a("p",[a("code",[v._v("就是把任意长度的输入，通过哈希算法，变换成固定长度的输出，该输出就是哈希值")])]),v._v(" "),a("p",[v._v("这转换是一种压缩映射，也就是，哈希值的空间通常远小于输入的空间，不同的输入可能会哈希成相同的输出，所以不可能从哈希值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数")]),v._v(" "),a("p",[v._v("所有的哈希函数都有一个共同的特点：")]),v._v(" "),a("p",[a("code",[v._v("根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同")])]),v._v(" "),a("p",[v._v("两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做"),a("code",[v._v("碰撞")])]),v._v(" "),a("p",[v._v("常见的几个哈希函数：")]),v._v(" "),a("blockquote",[a("p",[v._v("直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址")]),v._v(" "),a("p",[v._v("数字分析法：提取关键字中取值比较均匀的数字作为哈希地址")]),v._v(" "),a("p",[v._v("除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址")]),v._v(" "),a("p",[v._v("分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址")]),v._v(" "),a("p",[v._v("平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址")]),v._v(" "),a("p",[v._v("伪随机数法：采用一个伪随机数当作哈希函数")])]),v._v(" "),a("p",[v._v("衡量一个哈希函数的好坏的重要指标就是"),a("code",[v._v("发生碰撞的概率以及发生碰撞的解决方案")]),v._v("。任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种：")]),v._v(" "),a("ul",[a("li",[v._v("开放定址法：\n"),a("ul",[a("li",[v._v("开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入")])])]),v._v(" "),a("li",[v._v("链地址法\n"),a("ul",[a("li",[v._v("将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部")])])]),v._v(" "),a("li",[v._v("再哈希法\n"),a("ul",[a("li",[v._v("当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止")])])]),v._v(" "),a("li",[v._v("建立公共溢出区\n"),a("ul",[a("li",[v._v("将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中")])])])]),v._v(" "),a("h2",{attrs:{id:"hash-function"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-function"}},[v._v("#")]),v._v(" hash function")]),v._v(" "),a("p",[v._v("常见的哈希函数")]),v._v(" "),a("ul",[a("li",[v._v("直接定址法")]),v._v(" "),a("li",[v._v("除留余数法")]),v._v(" "),a("li",[v._v("数字分析法")]),v._v(" "),a("li",[v._v("平方取中法")]),v._v(" "),a("li",[v._v("折叠法")])]),v._v(" "),a("h2",{attrs:{id:"hash-methods"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-methods"}},[v._v("#")]),v._v(" hash methods")]),v._v(" "),a("h4",{attrs:{id:"开放定址法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开放定址法"}},[v._v("#")]),v._v(" 开放定址法")]),v._v(" "),a("p",[v._v("开放定址法是从发生冲突的单元开始，按照一定的次序，从散列表中找出一个空闲的存储单元，把冲突元素插入到该单元。插入到该单元的元素叫"),a("strong",[v._v("非同义词元素")])]),v._v(" "),a("h4",{attrs:{id:"线性探查法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线性探查法"}},[v._v("#")]),v._v(" 线性探查法")]),v._v(" "),a("p",[v._v("从发生冲突的单元开始，依次寻找下一个空闲单元。")]),v._v(" "),a("ul",[a("li",[v._v("特点：")])]),v._v(" "),a("ol",[a("li",[v._v("容易造成元素的"),a("strong",[v._v("堆积")])])]),v._v(" "),a("h4",{attrs:{id:"平方探查法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#平方探查法"}},[v._v("#")]),v._v(" 平方探查法")]),v._v(" "),a("p",[v._v("探查序列为 d, d+(1^2), d+(2^2), d+(3^2), ...")]),v._v(" "),a("ul",[a("li",[v._v("特点")])]),v._v(" "),a("ol",[a("li",[v._v("可以避免堆积现象；")]),v._v(" "),a("li",[v._v("无法探查到散列表上的所有单元，但至少可以探查到一半的单元")])]),v._v(" "),a("h4",{attrs:{id:"双散列函数探查法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双散列函数探查法"}},[v._v("#")]),v._v(" 双散列函数探查法")]),v._v(" "),a("p",[v._v("使用两个散列函数 h1 和 h2，若关键字通过第一个散列函数得出的下标 d 冲突的话，探查的增量为 h2(K)")]),v._v(" "),a("h4",{attrs:{id:"链接法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链接法"}},[v._v("#")]),v._v(" 链接法")]),v._v(" "),a("p",[v._v("把发生冲突的同义词元素用单链表链接起来，散列表则保存他们的表头指针")]),v._v(" "),a("ul",[a("li",[v._v("特点")])]),v._v(" "),a("ol",[a("li",[v._v("填充因子有可能会大于1；")]),v._v(" "),a("li",[v._v("比开放定址法占用更多存储空间用于存储表指针")])]),v._v(" "),a("h4",{attrs:{id:"对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[v._v("#")]),v._v(" 对比")]),v._v(" "),a("p",[v._v("开放定址法处理冲突的平均查找长度 > 链接法 > 任何其他查找方法")]),v._v(" "),a("h2",{attrs:{id:"disadvantages"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#disadvantages"}},[v._v("#")]),v._v(" disadvantages")]),v._v(" "),a("p",[v._v("哈希存储的缺点")]),v._v(" "),a("ol",[a("li",[v._v("计算散列地址需要花费时间，关键字不是整数还先要转换为整数；")]),v._v(" "),a("li",[v._v("占用更多的存储空间，开放定址法的装载因子小于1，链接法则需要空间存储指针；")]),v._v(" "),a("li",[v._v("只能按关键字查找，无法按非关键字查找")])])])}),[],!1,null,null,null);_.default=s.exports}}]);